# dart_classes_II

## toString მეთოდი

წინა გაკვეთილში განვიხილეთ მარტივი Rectangle კლასი:

```dart

void main() {
    Rectangle rect = Rectangle(3,5);
    print(rect);
}

class Rectangle {
    double side1 = 0;
    double side2 = 0;

    Rectangle(double a, double b) {
        side1 = a;
        side2 = b;
    }

    double calculatePerimeter() {
        return 2 * (side1 + side2);
    }
}

```

ამ მაგალითის main ფუნქციაში ჩვენ შევქმენით ობიექტი Rectangle კლასისაგან და შემდეგ ვცადეთ ამ ობიექტის print ფუნქციისათვის გადაცემა.
პროგრამის გაშვების შემდეგ კონსოლში დაიბეჭდა : Instance of 'Rectangle'. ეს მესიჯი გვამცონბს, რომ ობიექტი რომელიც print ფუნქციას გადეცა არის Rectangle მონაცემის ტიპის. ეს ინფორმაცია არც ისე გამოსადეგია ამიტომ ვნახოთ როგორ შეგვიძლია შევცვალოთ ეს ფუნქციონალი. ამისთვის შეგვიძლია გამოვიყენოთ toString მეთოდი (რომელიც ყველა კლასს აქვს და თუ რატომ შემდეგ გაკვეთილში ვნახავთ). მოდით დავამატოთ toString მეთოდი ჩვენს Rectangle კლასს

```dart

void main() {
    Rectangle rect = Rectangle(3,5);
    print(rect);
}

class Rectangle {
    double side1 = 0;
    double side2 = 0;

    Rectangle(double a, double b) {
        side1 = a;
        side2 = b;
    }

    double calculatePerimeter() {
        return 2 * (side1 + side2);
    }

    String toString() {
        return 'Rectangle{side1: $side1, side2: $side2}';
    }
}

```

ამ პროგრამის გაშვების შემდეგ კონსოლში დაიბეჭდება: 

Rectangle{side1: 3, side2: 5}

toString მეთოდი საშვალებას გვაძლევს ვნახოთ თუ რა არის ობიექტის ტექსტური რეპრეზენტაცია. იმის მიუეხდავად, რომ toString მეთოდის default ფუნქციონალი არც ისე სასარგებლოა ჩვენ შეგვიძლია შევცვალოთ ამ ფუნქციის დასაბრუნებელი მნიშვნელობა და დავაბრუნოთ ჩვენი პროგრამისათვის საჭირო ინფორმაცია. როგორც წესი ეს კლასის ცვლადების სახელები და მათი მნიშვნელობებია. ამ მაგალითში მოცემული ფორმატი არ არის სავალდებულო თუმცა გახლავთ დარტის სტანდარტი და მსგავს მაგალითებს ხშირად შევხვდებით.


## რა არის ობიექტზე ორიენტირებული პროგრამირება?
აქამდე ჩვენ ვისწავლეთ თუ როგორ დავწეროთ მარტივი კლასები, შევქმნათ კლასის ცვლადები, კონსტრუქტორები და მეთოდები. როგორც უკვე ბევრჯერ ვთქვით კლასების დახმარებით ჩვენ შეგვიძლია აღვწეროთ რეალურ სამყაროში არსებული ობიექტები. ამ გზით პროგრამების შექმნას ობიექტზე ორიენტირებულ პროგრამირებას ვუწოდებთ - Object Oriented Programming (OOP). გარდა აქამდე ნასწავლი OOP_ისთან დაკავშირებული სინტაქსისა, დარტი ისევე როგორც ბევრი სხვა პროგრამირების ენა გვთავაზობს დამატებით რამდენიმე ფუნქციონალს/სინტაქსს/კონცეპტს, რომლებიც გვეხმარება უფრო ეფექტურად შევძლოთ რეალური ობიექტების აღწერა ჩვენს პროგრამებში. ერთი ასეთი ფუნქციონალი გახლავთ მემკვიდრეობა, რომელსაც ჩვენ ამ გაკვეთილში შევისწავლით.

## მემკვიდრეობა
პროცესს, როდესაც კლასი იღებს სხვა კლასის ფუნქციონალსა და მახასიათებლებს, მემკვიდრეობას(Inheritance) ვუწოდებთ. მემკვიდრეობის დახმარებით შეგვიძლია შევქმნათ კლასთა იერარქიები, სადაც შვილი კლასები იღებენ მშობელი კლასების ფუნქციონალსა და მახასიათებლებს. რთულ სიტყვებს არ მისცე უფლება დაგაბნიონ სინდამდვილეში ყველაფერი ძალიან მარტივადაა. მოდით განვიხილოთ პატარა მაგალითი.

```dart

void main() {
    Dog doggo = Dog('doggo');
    print(doggo.name);
}

class Animal {
    String name;

    Animal(this.name);
}


class Dog extends Animal {
    Dog(super.name);
}

```

ზემოთ მოცემულ მაგალითში Animal კლასის სინტაქსი შენთვის ნაცნობი უნდა იყოს. რაც შეეხება Dog კლასს გვაქვს ორი ახალი keyword_ი
- extends ქივორდი დარტს ეუბნება, რომ Dog კლასი 'მემკვიდრეობით' მიიღებს Animal კლასის ცვლადებსა და ფუნქციებს (ამ შევთხვევაში Animal კლასს მხოლოდ ერთი ცვლადი აქვს).
- Animal კლასი კონსტრუქტორში ითხოვს String მონაცემის ტიპის ინფორმაციის გადაცემას. ამის გამო Dog კლასისაგან ობიექტის შექმნისას ეს მოთხოვნა უნდა დავაკმაყოფილოთ.
- Dog კლასის კონსტრუქტორი this ქივორდის მაგივრად იყენებს super ქივორდს. super keyword_ი მიუთითებს მშობელი კლასის name პარამეტრზე.

ამ პროგრამის main ფუნქციაში შევქმენით doggo ობიექტი და კონსტრუქტორს გადავაწოდეთ ძაღლის სახელი doggo. ამის შემდეგ Dog კლასის ობიექტი მიიღებს ამ ინფორმაციას და გადააწვდის მას Animal კლასის კონსტრუქტორს. super keyword ის გამოყენებით. Animal კლასის კონსტრუქტორი საბოლოო ჯამში შეინახავს მიღებულ ინფორმაციას name ცვლადში.

მიაქცი ყურადღება, რომ Dog კლასს არ გააჩნია name ცვლადი. ამის მიუხედავად ჩვენ შევძელით Dog ტიპის ობიექტზე name პარამეტრის გამოძახება, name პარამეტრი Dog კლასმა მემკვიდრეობით მიიღო Animal კლასისაგან.

მოდით ახლა ოდნავ გავართულოთ ჩვენი მაგალითი და Animal კლასში დავამატოთ მეთოდი.

```dart

void main() {
    Dog doggo = Dog('doggo');
    print(doggo.name);
    doggo.makeSound();
}

class Animal {
    String name;

    Animal(this.name);

    void makeSound() {
        print('$name is making sound');
    }
}


class Dog extends Animal {
    Dog(super.name);
}

```

პროგრამის გაშვების შედეგად დაიბეჭდება:
doggo
doggo is making sound


განახლებული მაგალითიდან შეგვიძლია მივხვდეთ, რომ კლასები მშობელი კლასებიდან, როგორც ცვლადებს ასევე მეთოდებსაც იღებენ მემკვიდრეობით.
მსგავსი მექანიზმი ზოგ შემთხვევაში გამოსადეგია, ხშირად კი შვილ კლასებში გვჭირდება მშობლის ფუნქციების ახლით შეცვლა. თუ კი Dog კლასში ჩვენ იგივე ფუნქციას აღვწერთ (იგივე დასაბრუნებელი მნიშნველობის მონაცემის ტიპი და იგივე სახელი) შეგვეძლება არსებული ფუნქციონალი ახლით შევცვალოთ. 

```dart

void main() {
    Dog doggo = Dog('doggo');
    print(doggo.name);
    doggo.makeSound();
}

class Animal {
    String name;

    Animal(this.name);

    void makeSound() {
        print('animal is making sound');
    }
}


class Dog extends Animal {
    Dog(super.name);

    @override
    void makeSound() {
        print('Woof Woof');
    }
}

```

ამ მაგალითში ჩვენ:
- Dog კლასში დავამატეთ makeSound მეთოდი. ამ გზით Animal კლასში არსებული იგივე სახელის მქონე მეთოდის ფუნქციონალი ახლით შევცვალეთ
- @override არის ეგრედ წოდებული ანოტაცია. დარტში ანოტაციები არ არის სავალდებულო, თუმცა ისინი ჩვენც და დარტსაც ეხმარება, რომ მარტივად მივხვდეთ, ახალ ფუნქციას ვქმნით, თუ არსებული ფუნქციის 'გადაწერას' ვცდილობთ.

ყველა კლასი რომელიც extends keyword_ის დახმარებით Animal კლასიდან მემკვიდრეობით მიიღებს makeSound მეთოდს, შეუძლია default ფუნქციონალი გამოიყენოს ან ახლით შეცვალოს. მაგალითად ქვემოთა მაგალითში ორი ახალი კლასი დავამატეთ Cat და Worm. Cat კლასი makeSound მეთოდს საკუთარი ფუნქციონალით ცვლის, Worm კლასი კი Animal კლასში აღწერილ makeSound მეთოდს იყენებს.

```dart

void main() {
    Dog doggo = Dog('doggo');
    doggo.makeSound(); // ბეჭდავს Woof

    Cat cat = Cat('ფისო');
    cat.makeSound(); // ბეჭდავს Meauu

    Worm worm = Worm('ჭიაყელა');
    worm.makeSound(); // ბეჭდავს animal is making sound
}

class Animal {
    String name;

    Animal(this.name);

    void makeSound() {
        print('animal is making sound');
    }
}


class Dog extends Animal {
    Dog(super.name);

    @override
    void makeSound() {
        print('Woof Woof');
    }
}

class Cat extends Animal {
    Cat(super.name);

    @override
    void makeSound() {
        print('Meauu');
    }
}

class Worm extends Animal {
    Worm(super.name);
}

```

## სხვადასხვა მონაცემის ტიპის სიები

პროგრამირებაში ხშირად არის ისეთი შემთხვევა როდესაც გვინდა ობიექტები შევინახოთ სიაში და მათზე ერთი და იგივე ოპერაცია შევასრულოთ (მაგალითად ერთი და იმავე ფუნქცია გამოვიძახოთ). ამის ერთერთი გზა სწორედ მემკვიდრეობაა. ზევით განხილული მაგალითის main ფუნქციაში შევქმნით სიას რომლის ელემენტები იქნებიან Animal ტიპის. რადგან ჩვენს მიერ შექმნილი დანარჩენი კლასები (Dog, Cat, Worm) არიან Animal კლასის შვილები, შეგვიძლია ეს ობიექტები შევინახოთ ამ სიაში.

```dart
void main() {
  Dog bimi = Dog('ბიმი');
  Dog roki = Dog('როკი');
  Dog bobi = Dog('ბობი');
  Cat fiso = Cat('ფისო');
  Cat kata = Cat('კატა');
  Cat fisunia = Cat('ფისუნია');
  Worm worm1 = Worm('ჭიაყელა');
  Worm worm2 = Worm('ჭია');
  Worm worm3 = Worm('მინიჭია');

  List<Animal> animals = [
    bimi,
    roki,
    bobi,
    fiso,
    kata,
    fisunia,
    worm1,
    worm2,
    worm3,
  ];

  for (int i = 0; i < animals.length; i++) {
    animals[i].makeSound();
  }
}

class Animal {
  String name;

  Animal(this.name);

  void makeSound() {
    print('animal is making sound');
  }
}

class Dog extends Animal {
  Dog(super.name);

  @override
  void makeSound() {
    print('$name ყეფს');
  }
}

class Cat extends Animal {
  Cat(super.name);

  @override
  void makeSound() {
    print('$name კნავის');
  }
}

class Worm extends Animal {
  Worm(super.name);
}


```

მოცემული პროგრამის გაშვების შემდეგ კონსოლში დაიბეჭდება:
ბიმი ყეფს
როკი ყეფს
ბობი ყეფს
ფისო კნავის
კატა კნავის
ფისუნია კნავის
animal is making sound
animal is making sound
animal is making sound

ამ პროგრამის main ფუნქციაში:
- შევქმენით 9 ობიექტი, 3 Dog ტიპის, 3 Cat ტიპის, 3 Worm ტიპის
- შევქმენით სია რომლის ელემენტების მონაცემის ტიპი გახლავთ Animal
- for ციკლის დახმარებით სიის ყველა ელემენტზე გამოვიძახეთ makeSound მეთოდი.

მსგავსი მაგალითები ამ კურსის განმავლობაში და ზოგადად პროგრამირებაში მრავლად შეგხვდებათ. შესაბამისად თუ ოდნავ მაინც გაუგებარია, თუ როგორ მუშაობს მოცემული კოდი, ან რაში გვჭირდება ასეთი ტიპის პროგრამების წერა, ცოტა ხანში უფრო და უფრო კარგად მივხვდებით ამას.

## Object კლასი
გაკვეთილის დასაწყისში, ჩვენ ვნახეთ toString მეთოდი, რომელიც როგორც ვთქვით ყველა კლასს გააჩნია. ალბათ უკვე მიხვდი თუ რაშია საქმე. სინამდვილეში დარტის ყველა კლასი (გარდა ერთი გამონაკლისისა რომელსაც მალე შევხვდებით) მემკვიდრეობით რამდენიმე მეთოდსა და ცვლადს იღებს ერთერთი კლასიდან. ამ კლასს Object კლასი ეწოდება და ერთი ასეთი მეთოდი გახლავთ toString. 